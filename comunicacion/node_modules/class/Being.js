exports.Being = function( params ){

	var defaults = {

		"type":"being",

		/*Objeto que contiene el sprite de THREE.JS*/
		"sprite":null,

		/* Id de identificacion unico*/
		"id":null,

		/*Angulo del Being*/
		"rotation":{
			"x":0,
			"y":0
		},

		/*Propiedad que define quien controla al Being*/
		"controls":null,

		/*Propiedad que define si el objeto puede Being atravesado*/
		"solid":true,

		"provisorio":{ // Vars PROVISORIAS que se borraran con three
			"timerCamina": null
		},

		/*Posicion del Being*/
		"position":{
			"x":0,
			"y":0
		},

		/*Direccion del Being*/
		"direction": 'up',

		/*Inventario del Being*/
		"inventory": [],

		/*Atributos de juego del Being*/
		"stats" : {

			"luck": 50e3,

			"level": { "min" : 1 , "max" : 50 },

			"experience": { "min" : 0 , "max" : 200 },

			"life": { "min" : 20 , "max" : 20 },

			"damage": { "min" : 2 , "max" : 4 },

			"critical" : 5e3,

			"shields": { "min" : 0 , "max" : 0 },

			"accurancy" : 100e3,

			"agility" : 10e3,

			"hunger" : { "min" : 100 , "max" : 100 },

			"thirst" : { "min" : 100 , "max" : 100 }

		},

		/*Modificadores de los atributos de juego del Being*/
		"modificators" : { /* Replica de stats */ },

		/*Estado actual del Being*/
		"state": {

			"alive": true,
			"poisoned": false,
			"freezed": false,
			"stoned": false,

		},

		/*Artefactos equipados del Being*/
		"equipped":{
			"head" : false,
			"neck" : false,
			"body" : false,
			"rightHand": false,
			"leftHand": false,
		},

	}



	//----------------------------------------------------------------------------------
	// Creamos propiedades para "Modificators"
	//----------------------------------------------------------------------------------

	// Crea propiedades modificators ( replica de stats )
	var addProps = (function createModificators(){
		for( modificator in defaults.stats ){
			defaults.modificators[modificator] = { "min" : 0 , "max" : 0 };
		}
	})();



	//----------------------------------------------------------------------------------
	// Merge
	// Mezcla de los defaults con los parametros pasados al objeto
	//----------------------------------------------------------------------------------

	merge( defaults , params , this );


	//----------------------------------------------------------------------------------
	// Metodos
	//----------------------------------------------------------------------------------

	this.createControls = function(){
		if( this.controls == "pc" ){
			//this.controls = new Controls();

			this.clientSendUp = (function(){
				var lastPosition = this.position;
				this.direction = 'up';
				this.move({"y":-1})
			}).bind(this);

			this.clientSendRight = (function(){
				var lastPosition = this.position;
				this.direction = 'right';
				this.move({"x":1})
			}).bind(this);

			this.clientSendDown = (function(){
				var lastPosition = this.position;
				this.direction = 'down';
				this.move({"y":1})
			}).bind(this);

			this.clientSendLeft = (function(){
				var lastPosition = this.position;
				this.direction = 'left';
				this.move({"x":-1})
			}).bind(this);

			this.clientSendAttack = (function(){
				this.attack();
			}).bind(this);

			// INVENTARIO
			this.clientSendTake = (function(){
				this.take();
			}).bind(this);

			// INVENTARIO
			this.clientSendDrop = (function(){
				this.drop();
			}).bind(this);

			//this.controls.init();

		}else if(this.controls == "npc"){

			var movement;
			//var follow = function(){
			function follow(){
				var lastPosition = this.position;
				//console.log( this.findNearest({ "target" : "being" }) );
				var destiny = this.findNearest({ "target" : "being" });
				if( destiny ){
					movement = this.goTo({ "destiny" : destiny });
					if( !movement.success ){

						console.log('oh!, algo bloquea mi camino!');
						if( movement.colision.being && movement.colision.being.controls != 'npc' ){
							console.log('Es un being!, a darle murra!')
							movement.colision.being.isAffected({
								"stats" : {
									"life": {
										"min":- this.calculeStat({ "stat" : "damage" , "target" : movement.colision.being }),
									}
								} ,
								/* Provisorio para que ataque, ahora los parametros estan dentro de stats, habria que recorrer ese array*/
								"author" : this
							});
						}
					}
				}

			}
			this.timerCamina = parseInt(setInterval( follow.bind(this) , 330 ))
			//this.provisorio.timerCamina = setInterval( (function(this){ return follow.bind(this)})(this), 1000); // previsorio ( hacer intervalo con three )

		}
	}

	this.createControls();

	this.goTo = function( params ){
		var destiny = params.destiny;
		//console.log('destiny',destiny)
		if( destiny.x < this.position.x ){
			this.direction = 'left';
			return this.move({"x":-1});
		}
		if( destiny.x > this.position.x ){
			this.direction = 'right';
			return this.move({"x":+1});
		}
		if( destiny.y > this.position.y ){
			this.direction = 'down';
			return this.move({"y":+1});
		}
		if( destiny.y < this.position.y ){
			this.direction = 'up';
			return this.move({"y":-1});
		}

		//destiny.y > this.position.y ? {"y":+1} : {"y":-1};
	}

	this.findNearest = function( params ){

		var target = params.target;

		var npc_vision = 15; // Radio de tiles que busca el npc
		var tile, has_floor, has_target;
		var taget_position = null;
		var forgetPositions = {};  // posiciones que ya miro y no encontro nada.
		var toSearch = [ this.position ]; // Posiciones que va a verificar, empieza por donde esta parado.
		var position_cardinal = [];
		var position_up, position_right, position_down, position_left // Posiciones que verifica por cada position.

		// Mientras haya posiciones para verificar
		do{
			// Guarda posiciones de alrededor de la posicion a verificar
			position_up 	= { "x" : toSearch[0].x 		, "y" : toSearch[0].y - 1  	};
			position_right 	= { "x" : toSearch[0].x + 1 	, "y" : toSearch[0].y  		};
			position_down 	= { "x" : toSearch[0].x 		, "y" : toSearch[0].y + 1  	};
			position_left 	= { "x" : toSearch[0].x - 1 	, "y" : toSearch[0].y  		};

			// Checkea:
			// 1 - Si existe el tile.
			// 2 - Si el terrain es solid (has_floor)
			// 3 - Si hay un target (has_target)
			tile = world.getTile( toSearch[0] );
			if( tile ){
				has_floor = tile.terrain.solid == false;
				if( tile[target] ){
					has_target = tile[ target ].controls != 'npc';
				}

				if( has_floor && has_target ){
					var target_position = toSearch[0];
					break;
				}
			}

			// Si ya tengo todas las posiciones necesarias, listo.
			if( this.position.y - npc_vision >= position_up.y ){
				break;
			}

			// Agrega posiciones a verificar de alrededor (son 4, en agujas del reloj) antes verifica si ya las miro.
			position_cardinal = [ position_up , position_right , position_down , position_left ];
			for( var p in position_cardinal ){
				if( !(('p' + position_cardinal[p].x + '-' + position_cardinal[p].y ) in forgetPositions) ){
					forgetPositions[ 'p' + position_cardinal[p].x + '-' + position_cardinal[p].y ] = null;
					toSearch.push( position_cardinal[p] );
				}
			}


			// Cuando ya verifico la posicion, la borra del array verificar y continua
			toSearch.splice(0,1);

		// Antes de continuar verifica si hace falta buscar mas posiciones libres
		}while( this.position.y - npc_vision < position_up.y );

		forgetPositions = null;
 		// encontro suficientes posiciones y las devuelve
 		return target_position;

	}


	//------------------------------------------------------------------------------------------------------
	// MOVIMIENTO
	//------------------------------------------------------------------------------------------------------

	this.move = function( params ){

		var x = params.x || 0;
		var y = params.y || 0;
		var lx = this.position.x;
		var ly = this.position.y;

		var new_position = { "x" : lx+x , "y" : ly+y};

		if( !this.collision({ "new_position": new_position }) ){
			this.position = new_position;

			this.updatePosition();
			world.refreshTiles({ "element":this , "lastPosition": { "x" : lx , "y" : ly } });

			return { "success" : true }
		}

		// devuelve objeto con el que colisiona
		return { "success" : false , "colision" : world.getTile( new_position ) }
	}


	//------------------------------------------------------------------------------------------------------
	// LUCHA
	//------------------------------------------------------------------------------------------------------

	// Ataque meele
	this.attack = function(){
		switch( this.direction ){
			case 'up':
				var attack_position = { x:this.position.x , y: this.position.y - 1 };
				break;
			case 'right':
				var attack_position = { x:this.position.x + 1 , y: this.position.y };
				break;
			case 'down':
				var attack_position = { x:this.position.x , y: this.position.y + 1 };
				break;
			case 'left':
				var attack_position = { x:this.position.x - 1, y: this.position.y };
				break;
		}
		var target = world.getTile( attack_position ).being;
		if( target ){
			target.isAffected({
				"stats" : {
					"life": {
						"min":- this.calculeStat({ "stat" : "damage" , "target" : target }),
					}
				} ,
				/* Provisorio para que ataque, ahora los parametros estan dentro de stats, habria que recorrer ese array*/
				"author" : this
			});
		}else{
			console.log('tiraste una piña al aire')
		}
	}

	// Suma stats con sus modificadores
	this.calculeStat = function( params ){
		var target = params.target || {};
		var stat = params.stat;
		var value = this.stats[ stat ].min;
		// Calcula base_damage
		if( stat == 'damage' ){

			// Mi Daño
			var damage_min = this.stats[ stat ].min + this.modificators[ stat ].min;
			var damage_max = this.stats[ stat ].max + this.modificators[ stat ].max;
			// Escudo del enemigo
			var shields_min = target.stats[ 'shields' ].min + target.modificators[ 'shields' ].min;
			var shields_max = target.stats[ 'shields' ].max + target.modificators[ 'shields' ].max;



			// Devuelve 1 si le emboco, 0 si le pifio
			var hitted = Math.random() < this.stats.accurancy / 100e3 ? 1 : 0;

			if( hitted ){

				// Calculo mi daño
				value = this.randomRange( damage_min , damage_max );
				// Resto escudos del enemigo
				value -= this.randomRange( shields_min , shields_max );
				value = (value > 0 ? value : 0);

				console.log('le has infligido daño: ' , value)
				return value;

			}else{
				console.log('pifiaste')
				return 0; // temporal, enviar despues si pifio.
			}
		}

		return value;

	}

	// Devuelve un numero al azar entre 2 numeros
	this.randomRange = function( val1 , val2 ){
		return Math.round( ( val1 - 0.49 ) + ( val2 - val1 + 0.49 ) * Math.random() );
	}

	// Afecta a los stats
	this.isAffected = function( params ){
		var stats = params.stats;
		var author = params.author;


		for( var stat in stats){

			// Escepciones:
			if( stat == 'life' ){ // Si supera a la vida max, vida min es igualada a vida max.
				if( (this.stats[stat].min + stats[stat].min) > this.stats[stat].max ){
					this.stats[stat].min = this.stats[stat].max
					this.updateStat({ 'stats' : stat });
					continue;
				}
			}

			// General
			this.stats[stat].min += stats[stat].min || 0;
			this.stats[stat].max += stats[stat].max || 0;

			this.updateStat({ 'stats' : stat });

		}

		// Dispara eventos asociados a los stats
		for( var stat in stats){
			if( this[stat+"Event"] ){
				this[stat+"Event"]( {"author":author} );
			}else{
				throw new Error('no existe la funcion '+stat+"Event")
			}
		}

	}

	// Tira todos los objetos del inventario
	this.dropAll = function(){
		// Si existen items
		if( this.inventory.length ){
			var numItems = this.inventory.length;
			var freePositions = this.findFreePositions({ "numItems":numItems });

			console.log( 'objetos en inventario:',numItems );
			// Tira un item en cada posicion vacia.
			for(var i = 0 ; i < numItems ; i++ ){
				this.throw({ "artifact" : this.inventory[i] , "position" : freePositions[i] })
			}
			// Vacio inventario.
			this.inventory = [];

			// Being invetory
			this.updateInvetory();

		}
	}

	this.throw = function( params ){

		// si Tile vacio y tira solo algunos -> Clona
		if( params.clone){
			var clonedArtifact = cloneObject( params.artifact );
			clonedArtifact.count = params.count;
			world.getTile( params.position ).artifact = clonedArtifact;

		// si Tile con artifacts iguales -> Suma cantidad
		}else if( params.count && params.is_in_floor ){
			params.artifact.count += params.count;
			console.log("cuanto suma?",params.count)

		// si Tile vacio -> Tira el Artifact (el total de lo que tenga)
		}else if( !params.is_in_floor ){
			console.log('Se cae '+ params.artifact +' en: '+ params.position )
			world.getTile( params.position ).artifact = params.artifact;
		}
		world.updateArtifact( { 'artifact' : params.artifact } );
		//this.updateSwapTile({ 'object' : params.artifact , 'lastPosition' : this.position });
		world.refreshTiles( {'element' : params.artifact} );

	}

	// Encuentra posiciones libres alrededor del personaje. Segun la cantidad dada.
	this.findFreePositions = function( params ){

		var freePositions = []; // Posiciones donde tirar artifacts
		var forgetPositions = {}; // Posiciones donde tirar artifacts
		var toSearch = [ this.position ]; // Posiciones que va a verificar, empieza por donde esta parado.
		var full; // Ya esta ocupado ( actualmente )
		var used; // Ya esta ocupado ( futuro )
		var tile; // Lo uso para ver existencia del tile. (bordes del mapa)
		var position_cardinal = [];
		var position_up, position_right, position_down, position_left // Posiciones que verifica por cada position.

		// Mientras haya posiciones para verificar
		do{
			// Guarda posiciones de alrededor de la posicion a verificar
			position_up 	= { "x" : toSearch[0].x 		, "y" : toSearch[0].y - 1  	};
			position_right 	= { "x" : toSearch[0].x + 1 	, "y" : toSearch[0].y  		};
			position_down 	= { "x" : toSearch[0].x 		, "y" : toSearch[0].y + 1  	};
			position_left 	= { "x" : toSearch[0].x - 1 	, "y" : toSearch[0].y  		};

			// Checkea:
			// 1 - Si existe el tile.
			// 2 - Si esta siendo ocupado ahora por un artifact. (full)
			// 3 - Si el terrain es solid (has_floor)
			tile = world.getTile( toSearch[0] );
			if( tile ){
				full = tile.artifact;
				has_floor = tile.terrain.solid == false;

				if( !full && has_floor ){
					freePositions.push( toSearch[0] );
				}
			}

			// Si ya tengo todas las posiciones necesarias, listo.
			if( params.numItems <= freePositions.length ){
				break;
			}

			// Agrega posiciones a verificar de alrededor (son 4, en agujas del reloj) antes verifica si ya las miro.
			position_cardinal = [ position_up , position_right , position_down , position_left ];
			for( var p in position_cardinal ){
				if( !(('p' + position_cardinal[p].x + '-' + position_cardinal[p].y ) in forgetPositions) ){
					forgetPositions[ 'p' + position_cardinal[p].x + '-' + position_cardinal[p].y ] = null;
					toSearch.push( position_cardinal[p] );
				}
			}
			// Cuando ya verifico la posicion, la borra del array verificar y continua
			toSearch.splice(0,1);

		// Antes de continuar verifica si hace falta buscar mas posiciones libres (ya lo hace antes pero por las dudas)
		}while( params.numItems > freePositions.length );

 		// encontro suficientes posiciones y las devuelve
 		return freePositions;

	}

	// Dar experiencia al que me mato.
	this.giveExperience = function( params ){
		params.author.isAffected({ "stats":{ "experience": {"min": +this.calculeStat({ "stat" : "points" })} } });
		console.log('Experiencia: ',params.author.stats.experience);
	}

	this.dead = function(){
		this.dropAll();
		this.state.alive = false;
		if( this.controls == 'npc' ){
			clearInterval(this.provisorio.timerCamina);
			this.remove();
		}else if( this.controls != 'npc' ){ // si es pc
			this.remove(); // temporal
		}

		this.updateState({ 'state' : 'alive' });

	}

	// Remueve todas las instancias del objeto ( en world y en el tile )
	this.remove = function(){

		world.removeObject({ "object" : this })
		world.getTile( this.position ).remove({ "type" : "being" });

		//this.updateTile({ 'object' : this });
		world.updateRemoveTile({ 'object' : this , 'lastPosition' : this.position });
		world.updateWorldObjects({ "delete" : null }); // acutaliza createdObjects

	}



	//------------------------------------------------------------------------------------------------------
	// ACCIONES
	//------------------------------------------------------------------------------------------------------

	// Tomar objetos del piso
	this.take = function(){
		var artifact = world.getTile( this.position ).artifact;
		if( artifact ){

			// Si existe en inventario, suma cantidad
			for( var item in this.inventory ){
				if( this.inventory[item].constructor === artifact.constructor ){
					this.inventory[item].count += artifact.count ;
					world.getTile( this.position ).artifact = null;
					console.log(artifact.id+" adquirida!");
					this.updateInventory();
					world.updateRemoveTile({ 'object' : artifact , 'lastPosition' : artifact.position });
					return true;
				}
			}
			// Si no lo tiene en inventario..
			this.inventory.push(artifact);
			world.getTile( this.position ).artifact = null;
			console.log(artifact.id+" adquirida!");

			// Invetario
			this.updateInventory();
			world.updateRemoveTile({ 'object' : artifact , 'lastPosition' : artifact.position });

		}else{
			console.log('No hay nada ahi');
		}
		console.log(this.inventory)
	}

	// Tirar objeto al piso
	this.drop = function( params ){
		var params = params || {};
		var dropAmount = params.dropAmount !== undefined ? params.dropAmount : null; // Si el user no le dijo cuantos, entonces es 1
		var tileArtifact = world.getTile( this.position ).artifact;
		// Si no tiene equipado el artifact
		if( !this.isEquipped({"artifact" : this.inventory[0]}) ){
			// Si hay artifact para tirar al piso
			if( this.inventory.length ){
				// Si hay espacio en el piso, o si esta ocupado pero es el mismo item, entonces puede tirarlo.
				if( !tileArtifact || tileArtifact.constructor == this.inventory[0].constructor ){

					var artifact_dropped = this.inventory[0];
					artifact_dropped.position = this.position;

					// Si tiene mas de 1, pregunta cantidad ( si el user no dijo todavia la cantidad )
					if( artifact_dropped.count > 1 && params.dropAmount == null ){
						SERVER.askDrop({ "userId" : this.id });
						return false;
					}else{
						dropAmount = 1;
					}

					// Tiro todos los que tengo
					if( artifact_dropped.count == 1 || artifact_dropped.count <= dropAmount ){

						this.inventory.splice(0,1); // Borro del inventario

						// Tile con artifacts iguales -> Suma cantidad
						if( tileArtifact ){
							this.throw({ "artifact" : tileArtifact , "position" : this.position , "count" : dropAmount , "is_in_floor" : true })
						}else{ // Tile vacio -> Tira Todos
							this.throw({ "artifact" : artifact_dropped , "position" : this.position })
						}

					}else{
					// Si tiro mas de 1

						this.inventory[0].count -= dropAmount; // Se descuenta cantidad al inventario

						// Tile con artifacts iguales -> Suma cantidad
						if( tileArtifact ){
							this.throw({ "artifact" : tileArtifact , "position" : this.position , "count" : dropAmount , "is_in_floor" : true })
						}else{ // Tile vacio -> Clona artifact en el piso
							this.throw({ "artifact" : artifact_dropped , "position" : this.position , "count" : dropAmount , "clone" : true})
						}

					}

					// Invetario
					this.updateInventory();


					console.log(artifact_dropped.id+" lanzada al piso.");
				}else{
					console.log('No hay espacio en el piso.');
				}
			}else{
				console.log('No tenes artefactos para tirar.');
			}
		}else{
			console.log('Tenes equipado el artifact');
		}
		console.log(this.inventory);
	}


	this.equip = function( params ){
		var artifact = this.inventory[ params.slot ];
		var placeEquip = this.canEquip({ "artifact" : artifact });

		// Si no existe nada equipado en el mismo lugar
		for( var place in placeEquip ){
			// Equipa
			this.equipped[placeEquip[place]] = artifact;
			console.log("equipado")
		}

		// Agrega modificadores del objeto al being
		for( modificator in artifact.modificators ){
			this.modificators[ modificator ].min = artifact.modificators[ modificator ].min;
			this.modificators[ modificator ].max = artifact.modificators[ modificator ].max;
		}

		this.updateEquipment();

	}



	this.unEquip = function( params ){
		var artifact = this.inventory[ params.slot ];
		// Verifica si ya tiene equipado ese mismo objeto
		if( this.isEquipped({ "artifact" : artifact }) ){
			// Busca en donde se equipa el objeto y lo desequipa
			for( var place in artifact.equipable){
				this.equipped[artifact.equipable[place]] = false;
				console.log("desequipado")
			}
		}

		// Resetea modificadores
		for( modificator in artifact.modificators ){
			this.modificators[ modificator ].min = 0;
			this.modificators[ modificator ].max = 0;
		}

		this.updateEquipment();
	}

	// Verifica si esta equipado
	this.isEquipped = function( params ){
		var artifact = params.artifact;
		if( artifact == undefined) { return false;}
		// Verifica la parte del cuerpo donde se equipa el objeto y compara con el objeto que ya esta equipado, para ver si es el mismo.
		for( var place in artifact.equipable){
			if( this.equipped[artifact.equipable[place]] == artifact ){
				return true;
			}
		}
		console.log('Nada para desequipar')
		return false;
	}

	// Verifica si puede equipar
	this.canEquip = function( params ){
		var artifact = params.artifact;
		var canEquip = [];

		// Verifica la parte del cuerpo donde se equipa y se fija si ya hay algo equipado.
		for( var place in artifact.equipable){
			if( this.equipped[artifact.equipable[place]] ){
				console.log('Ya tenes algo equipado ahi.')
				return false;
			}
			canEquip.push( artifact.equipable[place] );
		}
		return canEquip;
	}

	/*
		Usar un objeto
	*/

	this.use = function( params ){
		// Si no puede usar el objeto envia un mensaje y termina
		var artifact = this.inventory[params.slot];
		if( !artifact.usable ) {
			this.think({"message":"No puedo usar este objeto"});
			return false;
		}

		// Si puede usarlo ejecuta lo siguiente
		var stats = {}
		for( var modificator in artifact.modificators ){
			stats[modificator] = artifact.modificators[modificator];
		}
		this.isAffected({
			"stats":stats,
			"author":artifact
		});

		this.think({"message":"Usé mi " + artifact.id + "."});

		if(artifact.consumable){
			console.log("borrando ");
			world.removeObject({"object":artifact});
			this.inventory[params.slot] = null;
		}
		return true;
	}
	/*
		PROVISORIO
	*/

	this.createArtifact = function( params ){
		var artifact = params.artifact;

		var newArtifact = new artifact({"position":this.position} );

		this.take();
	}


	//------------------------------------------------------------------------------------------------------
	// ACCIONES PASIVAS
	//------------------------------------------------------------------------------------------------------

	// Mensajes con informacion de las interacciones. ( Feedback para el usuario )
	this.think = function( params ){
		var message = params.message;
		console.log( message );
	}

	this.refreshOrganism = function( ){

		var hunger = setInterval(function(){
			this.stats.hunger.min -= 2;
			this.stats.thirst.min -= 4;
		},18000);

	}

	//------------------------------------------------------------------------------------------------------
	// Events: disparan eventos segun el valor de las propiedades
	//------------------------------------------------------------------------------------------------------

	// Subir de nivel
	this.experienceEvent = function(){
		if( this.stats.experience.min >= this.stats.experience.max ){
			this.think({ "message" : 'He leveado!'})
			// Experiencia
			this.stats.experience.min -= this.stats.experience.max;
			this.stats.experience.max *= world.stats.levelGrowth.experience;
			// Level
			this.stats.level.min ++;
			// Mejorar stats
			this.stats.life.min = this.stats.life.max += world.stats.levelGrowth.life;
			this.stats.damage.min += world.stats.levelGrowth.damage;
			this.stats.damage.max += world.stats.levelGrowth.damage;

			this.updateStat({ 'stats' : 'experience' });
			this.updateStat({ 'stats' : 'level' });
			this.updateStat({ 'stats' : 'damage' });
		}
	}

	// Morir de hambre
	this.hungerEvent = function(){

	}

	// Morir de sed
	this.thristEvent = function(){

	}

	// Cada vez que se le modifica la vida.
	this.lifeEvent = function( params ){
		if( this.stats.life.min <=0 ){
			this.dead();
			this.giveExperience({ "author" : params.author });
			console.log('Te mato ' + params.author.id )
		}
	}

	/*
		Funcion provisoria
	*/
	this.statsEvent = function(){}

	this.authorEvent = function(){}


	//------------------------------------------------------------------------------------------------------
	// Fisica
	//------------------------------------------------------------------------------------------------------

	// Verifica colision con cualquier elemento que sea solido.
	this.collision = function( params ){
		var actualTile = world.getTile( params.new_position );
		return (
			/*	Verifica colision con los bordes del escenario */
			this.boundaries( params.new_position ) ||
			/* Verifica colision con un ser y si el ser es solido */
			( actualTile.being		&&	actualTile.being.solid )	||
			/* Verifica colision con un terreno y si el terreno es solido */
			( actualTile.terrain	&&	actualTile.terrain.solid )	||
			/* Verifica colision con un artefacto y si el artefacto es solido */
			( actualTile.artifact	&& 	actualTile.artifact.solid )
		);
	}

	// Bordes del mapa
	this.boundaries = function( new_position ){
		return ( new_position.x < 0 || new_position.x >= 30 || new_position.y < 0 || new_position.y >= 30 );
	}





	//------------------------------------------------------------------------------------------------------
	// Update (client)
	//------------------------------------------------------------------------------------------------------

	// Being
	this.updateInventory = function(){ // Actualiza todo el invatario
		SERVER.queue({
			"being" : this.id ,
			"controls": this.controls,
			"data" : { "all" : [ { "tree" : ['inventory'] , "value" : this.inventory } ] }
		});
	}

	// Being
	this.updateState = function( params ){ // Actualiza un state del being

		SERVER.queue({
			 "being" : this.id ,
			 "controls" : this.controls,
			 "data" : { "all" : [ { "tree" : ['state',params.state] , "value" : this.state[ params.state ] } ] }
		});

	}

	// Being
	this.updateStat = function( params ){ // Actualiza un stat del being

		SERVER.queue({
			 "being" : this.id ,
			 "controls" : this.controls,
			 "data" : { "all" : [ { "tree" : ['stats',params.stats] , "value" : this.stats[ params.stats ] } ] }
		});

	}

	// Being
	this.updatePosition = function( params ){ // Actualiza posicion del being
		SERVER.queue({
			"being" : this.id ,
			"controls" : this.controls,
			"data" : { "all" : [
				{ "tree" : ['position'] , "value" : this.position } ,
				{ "tree" : ['direction'] , "value" : this.direction }
			] }
		});
	}

	// Being
	this.updateEquipment = function(){
		SERVER.queue({
			"being" : this.id ,
			"controls" : this.controls,
			"data" : { "all" : [
				{ "tree" : ['equipped'] , "value" : this.equipped } ,
				{ "tree" : ['modificators'] , "value" : this.modificators }
			] }
		});
	}

	// Being
	this.updateModificators = function(){
		// Todavia sin usar.
	}





}
